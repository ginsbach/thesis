\centering
\begin{minipage}[t]{\textwidth}
\centering
\begin{minipage}[t]{\textwidth}
\centering
{\bf(a)} C program code:
\begin{lstlisting}[numbers=none,framexleftmargin=0pt,xleftmargin=0pt,language=C,basicstyle=\small\ttfamily]
 double example(double a, double b) {return sqrt(a*a) + sqrt(b*b); }
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{7.1cm}
\centering
{\bf(b)} Resulting LLVM IR:
\begin{lstlisting}[language={LLVM}]
define double @example(    
 double %0,                
 double %1) {              
 %3 = fmul double %0, %0   
 %4 = call double @sqrt(%3)
 %5 = fmul double %1, %1   
 %6 = call double @sqrt(%5)
 %7 = fadd double %4, %6   
 ret double %7 }
declare double @sqrt(double)      
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{3.5cm}
\centering
{\bf(c)} First solution:
\begin{lstlisting}[numbers=none,framexleftmargin=0pt,xleftmargin=0pt,language=LLVM]

a = %0

square = %3
sqrt_call = %4 




sqrt_fn = @sqrt
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{3.5cm}
\centering
{\bf(d)} Second solution:
\begin{lstlisting}[numbers=none,framexleftmargin=0pt,xleftmargin=0pt,language=LLVM]


a = %1


square = %5
sqrt_call = %6


sqrt_fn = @sqrt
\end{lstlisting}
\end{minipage}
\end{minipage}

\vspace{1em}
\begin{minipage}[t]{\textwidth}
\begin{minipage}[t]{0.493\textwidth}
\centering
{\bf(e)} Verification of first solution:
\begin{lstlisting}[language=CAnDL,numbers=none,framexleftmargin=0pt,xleftmargin=0pt]
( opcode{%4} = call
([$\tt \land$]) {%4}.args[0] = {@sqrt}
([$\tt \land$]) function_name{@sqrt} = sqrt
([$\tt \land$]) {%4}.args[1]  = {%3}
([$\tt \land$]) opcode{%3} = fmul
([$\tt \land$]) {%3}.args[0] = {%0}
([$\tt \land$]) {%3}.args[1] = {%0})
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{0.493\textwidth}
\centering
{\bf(f)} Verification of second solution:
\begin{lstlisting}[language=CAnDL,numbers=none,framexleftmargin=0pt,xleftmargin=0pt]
( opcode{%6} = call
([$\tt \land$]) {%6}.args[0] = {@sqrt}
([$\tt \land$]) function_name{@sqrt} = sqrt
([$\tt \land$]) {%4}.args[1]  = {%5}
([$\tt \land$]) opcode{%5} = fmul
([$\tt \land$]) {%5}.args[0] = {%1}
([$\tt \land$]) {%5}.args[1] = {%1})
\end{lstlisting}
\end{minipage}
\end{minipage}

\vspace{1em}
\begin{minipage}[t]{\textwidth}
\centering
{\bf(g)} C++ transformation code:
\begin{lstlisting}
using namespace std;
using namespace llvm;
void transform(map<string,Value*> solution, Function* abs) {
    ReplaceInstWithInst(
       dyn_cast<Instruction>(solution["sqrt_call"]),
       CallInst::Create(abs, {solution["a"]}));
}
\end{lstlisting}
\end{minipage}

\vspace{1em}
\begin{minipage}[t]{\textwidth}
\centering
{\bf(h)} Transformed LLVM IR after dead code elimination:
\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM}]
define double @example(double %0, double %1) {              
 %3 = call double @abs(double %0) 
 %4 = call double @abs(double %1)
 %5 = fadd double %3, %4   
 ret double %5 }
\end{lstlisting}
\end{minipage}

\caption{Demonstration of CAnDL specification in \Cref{fig:candlspec}
         on an example C program ({\bf a}):
         In the generated LLVM IR code ({\bf b}), two instances
         ({\bf c},{\bf d}) of {\tt SqrtOfSquare} are detected that fulfil all
         the constraints ({\bf e}, {\bf f}).
         Applying a transformation is simple ({\bf g}) and results in efficient
         code ({\bf h}).\parfillskip=0pt}