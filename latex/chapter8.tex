
    This thesis developed a constraint programming methodology that operates
    directly of static single assigment compiler intermediate representation.

\section{Contributions}

    The major contributions are the introduction of two constraint programming
    languages with full implementations.
    Secondly, the formulation of important computational idioms in those.
    And third the prototyping of an integrated heterogeneous acceleration
    pipeline built on thta technology.

\section{Critical Analysis}

    Several iddues remain with the work.
    Only a finite number of variables.
    Programs difficult to debug.
    SSA model needs to be reconstructed whenever acting on the results.

    \paragraph*{Compile Time Cost}

    \paragraph*{Finite Varaiable Numbers}
    The most visually apparent imperfection of both CAnDL and IDL is the
    limitation to a finite amount of variables in the underlying constraint
    problem.
    This results in upper bounds for the number of features in almost all idioms
    that have no fundamental justification:
    CReHCs can only contain a maximum of two histograms, stencil codes can only
    use a neighbourhood of up to 32 items, and so on.
    In practice, this involves a tradeoff between performance and the genreality
    of the idiom specification, as each additional variable introduces a slight
    overhead for the solver.

    Similar problems are well-known in other research disciplines that involve
    an underlying solver.
    Most prominently, bounded model checking techniques are built on SMT solvers
    with the same limitation.
    The same solution could be applied to IDL: Just repeatedly run the solver
    with more and more variables, up to a certain boundary.
    That way easy solutions are quickly found, but difficult solutions are not
    discarded entirely.

    \paragraph*{Acting on Solutions Invalidates SSA Model}

\section{Future Work}

    Future work will focus on extending the approach to pointer-intensive
    idioms, improving the usability of specification, and complementing
    the static approaches with established dynamic techniques.

    \paragraph*{Additional Idioms}
    The ability to express sparse linear algebra sets the detection ability of
    constraint programming on compiler immediate representation apart from
    previous approaches, involving the polyhedral model or data-flow analysis.
    Going beyond sparse data access, IDL could be used to formulate data access
    patters that involve pointer chases.
    This would enable it to detect graph operations, such as depth-first search
    and the PageRank algorithm.
    Furthermore, this approach could detect list traversal, insertion, and
    removal of elements.
    Such operations are not typically performance critical, but could be a first
    step to a deeper semantic understanding of programs in compilers.

    \paragraph*{Simplify Specification Languages}
    The specification languages CAnDL and IDL enable the detection of
    sophisticated computational idioms, but profound knowledge of compilers is
    required to sucessfully write correct specifications. 
    Furthermore, the presented specifications are almost entirely independent of
    the specific underlying intermediate representation LLVM IR.
    However, the precise extent of this independence left unclear.

    Future work will investigate higher-level languages that abstract away the
    IR-specific nature of CAnDL and IDL, and provide a more streamlined
    programming experience.
    The pseudocode and corresponding IDL specifications in
    \Cref{csr_lilacwhat_fig,jds_lilacwhat_fig} in \Cref{chapter:idioms} already
    suggest how this can be achieved:
    For many restricted domains (in that case SPMV), generating IDL code from
    high-level expressions is straightforward.

    \paragraph*{Complementing Dynamic Approaches}
    Several shortcomings of the presented approaches could be alleviated with
    dynamic approaches that complement the entirely static nature of constraint
    programming on compiler immediate representation.

    Dynamic analysis could be used to preselect candidate loops, drastically
    reducing the compile time overhead.
    Dynamic methods are required to efficiently transfer memory between
    heterogeneous participants, and to rule out pointer aliasing.

    \paragraph*{Generating Specifications by Example}
    Specification could be generated from example.
    



