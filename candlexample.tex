\begin{minipage}[t]{17.5cm}
\centering
\begin{minipage}[t]{6.422cm}
\centering
{\bf(a)} CAnDL program:
\begin{lstlisting}[language=CAnDL,basicstyle=\linespread{1.5565}\scriptsize\ttfamily]
Constraint SqrtOfSquare
( opcode{sqrt_call} = call
@∧@ {sqrt_call}.args[0]  = {sqrt_fn}
@∧@ function_name{sqrt_fn} = sqrt
@∧@ {sqrt_call}.args[1]  = {square}
@∧@ opcode{square} = fmul
@∧@ {square}.args[0] = {a}
@∧@ {square}.args[1] = {a})
End
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{11cm}
\centering
\begin{minipage}[t]{11cm}
\centering
{\bf(b)} C program code:
\begin{lstlisting}
double example(double a, double b) { return sqrt(a*a) + sqrt(b*b); }
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{4.785cm}
\centering
{\bf(c)} Resulting LLVM IR:
\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM}]
define double @example(    
 double %0,                
 double %1) {              
 %3 = fmul double %0, %0   
 %4 = call double @sqrt(%3)
 %5 = fmul double %1, %1   
 %6 = call double @sqrt(%5)
 %7 = fadd double %4, %6   
 ret double %7 }
declare double @sqrt(double)      
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{3.03cm}
\centering
{\bf(d)} First solution:
\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM},numbers=none]

a = %0

square = %3
sqrt_call = %4 




sqrt_fn = @sqrt
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{3.03cm}
\centering
{\bf(e)} Second solution:
\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM},numbers=none]


a = %1


square = %5
sqrt_call = %6


sqrt_fn = @sqrt
\end{lstlisting}
\end{minipage}
\end{minipage}
\end{minipage}

\begin{minipage}[t]{17.5cm}
\centering
\begin{minipage}[t]{9.743cm}
\centering
{\bf(f)} C++ transformation code:
\begin{lstlisting}
void transform(map<string,Value*> solution, Function* abs) {
    ReplaceInstWithInst(
       dyn_cast<Instruction>(solution["sqrt_call"]),
       CallInst::Create(abs, {solution["a"]}));
}
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{7.652cm}
\centering
{\bf(g)} Transformed LLVM IR after DCE:
\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM}]
define double @example(double %0, double %1) {              
 %3 = call double @abs(double %0) 
 %4 = call double @abs(double %1)
 %5 = fadd double %3, %4   
 ret double %5 }
\end{lstlisting}
\end{minipage}
\end{minipage}
%Detected optimization opportunities:
%\begin{lstlisting}[escapeinside={(*}{*)},language={}]
%{ "sqrt_call" : %4,
%  "sqrt_func" : @sqrt,
%  "square" :   %3,
%  "a" :        %0 },
%{ "sqrt_call" : %6,
%  "sqrt_func" : @sqrt,
%  "square" :   %5,
%  "a" :        %1 }
%\end{lstlisting}
%Optimized LLVM IR:
%\begin{lstlisting}[escapeinside={(*}{*)},language={LLVM}]
%define double example(double %0, double %1) {
%  %3 = call double @fabs(double %0)
%  %4 = call double @fabs(double %1)
%  %5 = fadd double %3, %4
%  ret double %5
%}
%\end{lstlisting}
\vspace{-0.3cm}
\caption{Demonstration of a simple CAnDL program}
\label{fig:firstexample}