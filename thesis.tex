\documentclass[phd,icsa,twoside,logo,11pt]{infthesis}

\usepackage{appendix}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[numbers]{natbib}
\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{calligra}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tcolorbox}
\tcbuselibrary{theorems}
\usepackage{mathptmx}
\usepackage{enumitem}
\usepackage{pgfplots}
\usepackage{tabularx}
\usepackage{courier}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usetikzlibrary{patterns}
\pgfplotsset{compat=1.13}

\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

\hyphenpenalty=100000
\apptocmd{\sloppy}{\hbadness 2591\relax}{}{}

\Crefname{lstlisting}{Listing}{Listings}

\newtcbtheorem[auto counter,number within=chapter]{theorem}{Theorem}{
label type=theorem,
colback=white,
colframe=black,
fonttitle=\bfseries,
title={Theorem \thetcbcounter}}{theo}

\newtcbtheorem[auto counter,number within=chapter]{definition}{Definition}{
label type=definition,
colback=white,
colframe=black,
fonttitle=\bfseries,
title={Definition \thetcbcounter}}{def}

\newtcolorbox{blackbox}[1]{
top=0mm,
bottom=0mm,
left=0mm,
right=0mm,
boxsep=0mm,
toptitle=1mm,
bottomtitle=1mm,
colback=black,
colframe=black,
fonttitle=\centering\bfseries,
title=#1}

\newtcolorbox{blackwhitebox}[1]{
colback=white,
colframe=black,
fonttitle=\centering\bfseries,
title=#1}

\newtcolorbox{graybox}[0]{
top=0mm,
bottom=0mm,
left=0mm,
right=0mm,
colback=white!90!black,
colbacktitle=white!90!black,
colframe=white!50!black,
lower separated=false
}

\definecolor{color_strings}{HTML}{0F4D0F}
\definecolor{color_keywords}{HTML}{191980}
\definecolor{color_types}{HTML}{801919}
\definecolor{color_comment}{HTML}{FF0000}

\lstset{
    basicstyle         = \linespread{1}\ttfamily,
    stringstyle        = \color{color_strings}\bfseries,
    keywordstyle       = \color{color_keywords}\bfseries,
    keywordstyle       = [2]\color{color_types}\bfseries,
    keywordstyle       = [3]\bfseries,
    commentstyle       = \color{color_comment}\itshape,
    numbers            = left,
    numberstyle        = \scriptsize,
    numbersep          = 10pt,
    xleftmargin        = 1.5em,
    frame              = lines,
    framexleftmargin   = 1.5em,
    framexbottommargin = 0em,
    captionpos         = b,
    escapeinside       = {([}{])},
    literate           = {∧}{$\land$}1{∨}{$\lor$}1{∈}{$\in$}1{≠}{$\neq$}1
                         {Φ}{$\Phi$}1
}

\lstdefinelanguage{MyCpp}{
    morekeywords = {return, class, struct, public, private, goto, for, if, else,
                    virtual, override, while, template, auto, using, namespace},
    morekeywords = [2]{const, int, double, float, bool, size\_t, unsigned, void,
                       vector, array, shared\_ptr, pair, map, string, dyn\_cast,
                       Instruction, CallInst, Value, Function,
                       SkipResult, BacktrackingPart, Tree, ElementOfShared,
                       ElementOfPart, ConjunctionPart},
    morekeywords = [3]{true, false, FAIL, PASS, SUCCESS},
    morecomment  = [l]{//},
    morecomment  = [s]{/*}{*/},
    morestring   = [b]{"}
}

\lstdefinelanguage{BNF}{
    morecomment  = [s][\color{color_strings}\bfseries]{<}{>}
}

\lstdefinelanguage{CAnDL}{
    morekeywords = { Constraint, End, include, with, collect, foreach, forany,
                     for, unused, is, if, not, otherwise, specified},
    morecomment  = [s][\color{color_strings}\bfseries]{\{}{\}}
}

\lstdefinelanguage{IDL}{
    morekeywords = { Constraint, End, inherits, with, and, or, at, as },
    morecomment  = [s]{\{}{\}}
}

\lstdefinelanguage{LIFT}{
    morekeywords = {return, gemm\_in\_lift, map, fun, reduce, zip, transpose},
    morekeywords = [2]{float}
}

\title{From Constraint Programming\\to Heterogeneous Parallelism}
\author{Philip Ginsbach}

\abstract{
    The scaling limitations of homogeneous processing make it necessary for
    many applications to utilise heterogeneous parallelism, including
    graphics processors and increasingly also deep learning accelerators.
    This is a challenge for existing compilers that only target 
    homogeneous processors.
    Because heterogeneous acceleration is often only accessible via libraries
    and domain specific languages, expensive application rewrites become
    necessary.

    This thesis introduces a constraint programming methodology that is used to
    define and then automatically detect algorithmic structure in compiler
    intermediate representation.
    This allows compilers to tackle the challenge of automatic heterogeneous
    acceleration.

    Libraries and domain specific languages are able to efficiently target
    accelerators because they provide narrower interfaces.
    The more restrictive semantics of domain specific languages give their
    compilers more powerful models to analyse the program, making it possible to
    apply domain specific optimisations and better match the target hardware.
    The same is true for libraries, which can be thought of as particularly
    restrictive domain specific languages.

    Using constraint programming, compilers can recognise narrow interfaces
    within programs that are written in general purpose programming languages,
    such as C++.
    This includes parts of the program that adhere to the polyhedral model,
    implement linear algebra routines, or fall within a large  class of other
    algorithmic structures.
    Once a part of the program has been specialised, the general purpose
    compiler can reformulate it in a more restrictive model and pass it on to
    specialised tools for code generation.
    This allows for the automatic heterogeneous acceleration of previously
    sequential codes, without any need for manual source code changes.

    Starting from an abstract model of static single assignment form compiler
    representations, the constraint programming methodology is developed into a
    novel constraint programming language that is eventually used to implement a
    complete heterogeneous acceleration pipeline within LLVM.
    Many additional applications of this language are explored.
    This includes the parallelisation of histogram reductions that previously
    escaped compiler analysis, a formulation of the polyhedral code model,
    and the rapid prototyping of compiler optimisations.
}

\begin{document}
\begin{preliminary}
\maketitle
\begin{acknowledgements}

\end{acknowledgements}
\begin{declaration}
    I declare that this thesis was composed by myself, that the work contained
    herein is my own except where explicitly stated otherwise in the text, and
    that this work has not been submitted for any other degree or professional
    qualification except as specified.
    Some of the material used in this thesis has been published in the following
    papers:

    \begin{description}
    \small
        \item[\hspace{0.35cm}\citep{Ginsbach:2018:CDS:3178372.3179515}]
              Philip Ginsbach, Lewis Crawford and Michael F.\ P.\ O'Boyle.\\
              {\bf CAnDL: A Domain Specific Language for Compiler Analysis}.\\
              {\em Proceedings of the 27th International Conference on
               Compiler Construction (CC), 2018}
        \item[\hspace{0.35cm}\citep{ginsbach2017discovery}]
              Philip Ginsbach and Michael F.\ P.\ O'Boyle.\\
              {\bf Discovery and Exploitation of General Reductions: A
              Constraint Based Approach}.\\
              {\em Proceedings of the 15th Annual International
               Symposium on Code Generation and\\Optimization (CGO), 2017}
        \item[\hspace{0.35cm}\citep{Ginsbach:2018:AML:3173162.3173182}]
              Philip Ginsbach, Toomas Remmelg, Michel Steuwer, Bruno Bodin,
              Christophe Dubach and\\Michael F.\ P.\ O'Boyle.\\
              {\bf Automatic Matching of Legacy Code to Heterogeneous APIs: An
              Idiomatic Approach}.\\
              {\em Proceedings of the 23rd International Conference on
               Architectural Support for\\Programming Languages and Operating
               Systems (ASPLOS), 2018}
    \end{description}

    \par
\vspace{1in}\raggedleft({\em Philip Ginsbach})
\end{declaration}
\tableofcontents
\end{preliminary}
\chapter{Introduction}
    \label{chapter:introduction}
    \input{latex/chapter1}

\makeatletter
\@openrightfalse
\makeatother
\chapter*{}
\makeatletter
\@openrighttrue
\makeatother

\makeatletter
\@openrightfalse
\makeatother
\chapter*{List of Symbols and Notation}
    \input{latex/notation}
\makeatletter
\@openrighttrue
\makeatother

\chapter{Constraint Programming on Static Single Assignment Code}
    \label{chapter:theory}
    \input{latex/chapter2}

\chapter{Related Work}
    \label{chapter:literature}
    \input{latex/chapter3}

\chapter[The Compiler Analysis Description Language]
        {The Compiler Analysis Description Language
         \footnote{This chapter is based on published research in
                  \citet{Ginsbach:2018:CDS:3178372.3179515}.}}
    \label{chapter:candl}
    \input{latex/chapter4}

\chapter[Automatic Parallelisation of Complex Reductions and Histograms]
        {Automatic Parallelisation of Complex Reductions and Histograms
         \footnote{This chapter is based on published research in
                   \citet{ginsbach2017discovery}.}}
    \label{chapter:reductions}
    \input{latex/chapter5}

\chapter[Heterogeneous Acceleration with Computational Idioms]
        {Heterogeneous Acceleration with Computational Idioms
         \footnote{This chapter is based on published research in
                   \citet{Ginsbach:2018:AML:3173162.3173182}.}}
    \label{chapter:idioms}
    \input{latex/chapter6}

%\chapter[Building a Fully integrated Idiom Specific Optimization Pipeline]
%        {Building a Fully integrated Idiom Specific Optimization Pipeline
%         \footnote{This chapter is based on published research in
%                   \citet{lilacpaper}.}}
%    \label{chapter:lilac}
%    \input{latex/chapter7}

\chapter{Conclusions}
    \label{chapter:conclusion}
    \input{latex/chapter8}

\bibliographystyle{unsrtnat}
\bibliography{references}

\begin{appendices}
\chapter{Full Grammar of CAnDL}
    \label{appendix:CAnDLgrammar}
    \input{latex/appendixA}
\chapter{Polyhedral Code Sections in CAnDL}
    \label{appendix:CAnDLpoly}
    \input{latex/appendixB}
\end{appendices}

\end{document}
